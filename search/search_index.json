{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MongoX MongoX is an async python ODM (Object Document Mapper) for MongoDB which is built on top of Motor and Pydantic . The main features include: Fully type annotated Async support Python 3.7+ (since it's built on top of Motor) Elegant editor support (since it's built on top of Pydantic) Autocompletion everywhere, from object creation to query results Custom query builder which is more intuitive and pythonic 100% test coverage MongoX models are at the same time Pydantic models and have the same functionalitties, so you can use them with your existing Pydantic models. Documentation : https://aminalaee.github.io/mongox Installation $ pip install mongox Quickstart You can define mongox models the same way you define Pydantic models. The difference is they should inherit from mongox.Model now: import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model , db = db , collection = \"movies\" ): name : str year : int Now you can create some instances and insert them into the database: movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. So you will have type hints and validations everywhere. Now you can fetch some data from the database. You can use the same pattern as PyMongo/Motor: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () Or you can use Movie fields instead of dictionaries in the query (less room for bugs): movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use a more intuitive query (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Notice how we omitted the dictionary and passed the Movie fields in comparison. Please refer to the documentation here or the full examples here .","title":"Quickstart"},{"location":"#mongox","text":"MongoX is an async python ODM (Object Document Mapper) for MongoDB which is built on top of Motor and Pydantic . The main features include: Fully type annotated Async support Python 3.7+ (since it's built on top of Motor) Elegant editor support (since it's built on top of Pydantic) Autocompletion everywhere, from object creation to query results Custom query builder which is more intuitive and pythonic 100% test coverage MongoX models are at the same time Pydantic models and have the same functionalitties, so you can use them with your existing Pydantic models. Documentation : https://aminalaee.github.io/mongox","title":"MongoX"},{"location":"#installation","text":"$ pip install mongox","title":"Installation"},{"location":"#quickstart","text":"You can define mongox models the same way you define Pydantic models. The difference is they should inherit from mongox.Model now: import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model , db = db , collection = \"movies\" ): name : str year : int Now you can create some instances and insert them into the database: movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. So you will have type hints and validations everywhere. Now you can fetch some data from the database. You can use the same pattern as PyMongo/Motor: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () Or you can use Movie fields instead of dictionaries in the query (less room for bugs): movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use a more intuitive query (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Notice how we omitted the dictionary and passed the Movie fields in comparison. Please refer to the documentation here or the full examples here .","title":"Quickstart"},{"location":"cheat_sheet/","text":"All examples are provided for the following collection: import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model , db = db , collection = \"movies\" ): name : str year : int Model methods insert : Inserts the document. Example movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () movie = Movie ( name = \"Forrest Gump\" , year = 1994 ) await movie . insert () all : Returns list of all documents matching the query. Example movies = await Movie . query () . all () first : Returns first document matching the query or None . Example movie = await Movie . query ( Movie . name == \"Godfather\" ) . first () get : Returns one document matching the query. Example movie = await Movie . query ( Movie . name == \"Godfather\" ) . get () Warning This can throw NoMatchFound or MultipleMatchesFound . count : Returns count of documents matching the query. Example count = await Movie . query ( Movie . year > 2000 ) . count () delete : Delete a single document or multiple documents. Example # Delete many number_of_deleted = await Movie . query ( Movie . year < 1950 ) . delete () # Delete one movie = await Movie . query ( Movie . name == \"Emma\" ) . get () await movie . delete () limit : To limit number of documents returned. Example movies = await Movie . query () . limit ( 5 ) . all () skip : To skip number of documents for returning results. Example movies = await Movie . query () . skip ( 5 ) . all () movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all () sort : To sort query results. Example from mongox import Order movies = await Movie . query () . sort ( Movie . year , Order . DESC ) . all () query : To add another query to query. Example # These queries will have the same result movies = await Movie . query ( Movie . name > 2000 ) . query ( Movie . name < 2020 ) . all () movies = await Movie . query ( Movie . name > 2000 , Movie . name < 2020 ) . all () save : Saves the document with the current keys and values. Example movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () movie . year = 2000 await movie . save () Q operator Q.asc() : Create ascending order expression. Example movies = await Movie . query () . sort ( Q . asc ( Movie . year )) . all () Q.desc() : Create descending order expression. Example movies = await Movie . query () . sort ( Q . desc ( Movie . year )) . all () Q.in_() : Creates an $in operator in MongoDB. Example movies = await Movie . query ( Q . in_ ( Movie . year , [ 2000 , 2001 ])) . all () Q.not_in() : Creates an $nin operator in MongoDB. Example movies = await Movie . query ( Q . not_in ( Movie . year , [ 1999 , 2000 ])) . all () Q.and_() : Creates an $and operator in query. Example movies = await Movie . query ( Q . and_ ( Movie . year > 2000 , Movie . year < 2005 )) . all () Q.or_() : Creates an $or operator in query. Example movies = await Movie . query ( Q . or_ ( Movie . name == \"Hobbits\" , Movie . year > 2000 )) . all () Indexes Model.create_index() : Creates a single index defined in Model class. Example await Movie . create_index ( \"name\" ) Warning This can raise mongox.InvalidKeyException if index is not found in Model class. Model.create_indexes() : Creates indexes defined in Model class. Example await Movie . create_indexes () Warning This can raise pymongo.errors.OperationFailure exception. Model.drop_indexes() : Drops indexes of the collection. Example # Drops indexes defined in Movie class. await Movie . drop_indexes () Example # Drops all indexes of the collection. await Movie . drop_indexes ( force = True ) Warning This can raise pymongo.errors.OperationFailure exception. Model.drop_index() : Drops a single index by name. Example await Movie . drop_index ( \"name\" ) Warning This can raise mongox.InvalidKeyException if index is not found in Model class.","title":"Cheat Sheet"},{"location":"cheat_sheet/#model-methods","text":"insert : Inserts the document. Example movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () movie = Movie ( name = \"Forrest Gump\" , year = 1994 ) await movie . insert () all : Returns list of all documents matching the query. Example movies = await Movie . query () . all () first : Returns first document matching the query or None . Example movie = await Movie . query ( Movie . name == \"Godfather\" ) . first () get : Returns one document matching the query. Example movie = await Movie . query ( Movie . name == \"Godfather\" ) . get () Warning This can throw NoMatchFound or MultipleMatchesFound . count : Returns count of documents matching the query. Example count = await Movie . query ( Movie . year > 2000 ) . count () delete : Delete a single document or multiple documents. Example # Delete many number_of_deleted = await Movie . query ( Movie . year < 1950 ) . delete () # Delete one movie = await Movie . query ( Movie . name == \"Emma\" ) . get () await movie . delete () limit : To limit number of documents returned. Example movies = await Movie . query () . limit ( 5 ) . all () skip : To skip number of documents for returning results. Example movies = await Movie . query () . skip ( 5 ) . all () movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all () sort : To sort query results. Example from mongox import Order movies = await Movie . query () . sort ( Movie . year , Order . DESC ) . all () query : To add another query to query. Example # These queries will have the same result movies = await Movie . query ( Movie . name > 2000 ) . query ( Movie . name < 2020 ) . all () movies = await Movie . query ( Movie . name > 2000 , Movie . name < 2020 ) . all () save : Saves the document with the current keys and values. Example movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () movie . year = 2000 await movie . save ()","title":"Model methods"},{"location":"cheat_sheet/#q-operator","text":"Q.asc() : Create ascending order expression. Example movies = await Movie . query () . sort ( Q . asc ( Movie . year )) . all () Q.desc() : Create descending order expression. Example movies = await Movie . query () . sort ( Q . desc ( Movie . year )) . all () Q.in_() : Creates an $in operator in MongoDB. Example movies = await Movie . query ( Q . in_ ( Movie . year , [ 2000 , 2001 ])) . all () Q.not_in() : Creates an $nin operator in MongoDB. Example movies = await Movie . query ( Q . not_in ( Movie . year , [ 1999 , 2000 ])) . all () Q.and_() : Creates an $and operator in query. Example movies = await Movie . query ( Q . and_ ( Movie . year > 2000 , Movie . year < 2005 )) . all () Q.or_() : Creates an $or operator in query. Example movies = await Movie . query ( Q . or_ ( Movie . name == \"Hobbits\" , Movie . year > 2000 )) . all ()","title":"Q operator"},{"location":"cheat_sheet/#indexes","text":"Model.create_index() : Creates a single index defined in Model class. Example await Movie . create_index ( \"name\" ) Warning This can raise mongox.InvalidKeyException if index is not found in Model class. Model.create_indexes() : Creates indexes defined in Model class. Example await Movie . create_indexes () Warning This can raise pymongo.errors.OperationFailure exception. Model.drop_indexes() : Drops indexes of the collection. Example # Drops indexes defined in Movie class. await Movie . drop_indexes () Example # Drops all indexes of the collection. await Movie . drop_indexes ( force = True ) Warning This can raise pymongo.errors.OperationFailure exception. Model.drop_index() : Drops a single index by name. Example await Movie . drop_index ( \"name\" ) Warning This can raise mongox.InvalidKeyException if index is not found in Model class.","title":"Indexes"},{"location":"defining_documents/","text":"Defining documents As you probably already know, MongoDB databases have collections instead of tables. And each collection has documents instead of rows. You can define your documents by inheriting from mongox.Model . import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model , db = db ): name : str year : int First we create a mongox.Client instance with the MongoDB URI. Then we get a database from client by calling .get_database() . If you want to have more control over the client event loop, you can specify a callable to get event loop at runtime: client = mongox . Client ( \"mongodb://localhost:27017\" , get_event_loop = asyncio . get_running_loop ) By default, mongox.Client will use asyncio.get_running_loop . Model attributes are defined the same way as Pydantic. The Movie class is both a mongox Model and also a pydantic BaseModel . Now we have a Movie collection with attributes name and year . Field validation You can add field-level validations by using mongox.Field . This is actually just a short-cut to the Pydantic Field and accepts the same arguments. Let's say we want to limit the year attribute of Movie to be more strict: import mongox class Movie ( mongox . Model ): name : str year : int = mongox . Field ( gt = 1800 ) Now when creating a Movie instance, the year will be validated differently. This will be ok: await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () But this will throw a Pydantic ValidationError : await Movie ( name = \"Golden Oldie\" , year = 1790 ) . insert () # E pydantic.error_wrappers.ValidationError: 1 validation error for Movie # E year # E ensure this value is greater than 1800 (type=value_error.number.not_gt; limit_value=1800) Some of the most common Field arguments include: For numeric types like int , float and Decimal : gt Rquires the field to be greater than ge Rquires the field to be greater than or equal to le Rquires the field to be less than or equal to lt Rquires the field to be less than multiple_of Requires the field to be a multiple of For strings: min_length Requires the field to have a minimum length max_length Requires the field to have a maximum length regex Requires the field to match a regular expression For a full list of Field arguments you can refer to the Pydantic docs here . Defining indexes Mongox models accept indexes as a list of mongox.Index instances: import mongox indexes = [ mongox . Index ( \"name\" , unique = True ), mongox . Index ( keys = [( \"year\" , mongox . Order . DESCENDING ), ( \"genre\" , mongox . IndexType . HASHED )]), ] class Movie ( mongox . Model , db = db , indexes = indexes ): name : str genre : str year : int For creating Index objects we have two options, for simple cases we can do: Index ( key_name , ** kwargs ) But to have more control over index definition we can do: Index ( keys = [( key_name , index_order )], ** kwargs ) And then, you can then create the collection indexes with: await Movie . create_indexes () Or to drop the indexes: await Movie . drop_indexes () Note that this will only drop indexes defined in Movie model and won't affect the ones manually created. To drop all indexes, even those not defined here you can pass force=True : await Movie . drop_indexes ( force = True ) And finally if you need to drop a single index by name: await Movie . drop_index ( \"year_genre) Index accepts the following arguments: key For single key (simple indexes). keys List of keys and their types. name Can be specified or automatically generated from keys. background If the index creation should happen in the background. unique If the index should be a unique index. For example: Index ( keys = [( \"year\" , Order . DESCENDING )], name = \"year_index\" , background = True ) To specify order of index you can use mongox.Order : from mongox import Order Index ( keys = [( \"year\" , Order . ASCENDING )], name = \"year_index\" , background = True ) Order class has only two attributes ASCENDING and DESCENDING . And to specify custom index type, you can pass mongox.IndexType instead of index order: from mongox import IndexType Index ( keys = [( \"year\" , IndexType . HASHED )], name = \"year_index\" , background = True ) IndexType has the supported PyMongo index types: GEO2D GEOSPHERE HASHED TEXT For a full list of allowed arguments you can refer to the PyMongo docs here . Embedded Models Embedded Models are models to be embedded in mongox.Model . The difference is that EmbeddedModel s won't be inserted separately and won't get their seaparate _id . To define Embedded Models you should inherit from mongox.EmbeddedModel and define the fields the same as Pydantic. import mongox class Genre ( mongox . EmbeddedModel ): title : str class Movie ( mongox . Model ): name : str genre : Genre You can use EmbeddedModel to define multi-level nested objects in MongoDB.","title":"Defining documents"},{"location":"defining_documents/#defining-documents","text":"As you probably already know, MongoDB databases have collections instead of tables. And each collection has documents instead of rows. You can define your documents by inheriting from mongox.Model . import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model , db = db ): name : str year : int First we create a mongox.Client instance with the MongoDB URI. Then we get a database from client by calling .get_database() . If you want to have more control over the client event loop, you can specify a callable to get event loop at runtime: client = mongox . Client ( \"mongodb://localhost:27017\" , get_event_loop = asyncio . get_running_loop ) By default, mongox.Client will use asyncio.get_running_loop . Model attributes are defined the same way as Pydantic. The Movie class is both a mongox Model and also a pydantic BaseModel . Now we have a Movie collection with attributes name and year .","title":"Defining documents"},{"location":"defining_documents/#field-validation","text":"You can add field-level validations by using mongox.Field . This is actually just a short-cut to the Pydantic Field and accepts the same arguments. Let's say we want to limit the year attribute of Movie to be more strict: import mongox class Movie ( mongox . Model ): name : str year : int = mongox . Field ( gt = 1800 ) Now when creating a Movie instance, the year will be validated differently. This will be ok: await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () But this will throw a Pydantic ValidationError : await Movie ( name = \"Golden Oldie\" , year = 1790 ) . insert () # E pydantic.error_wrappers.ValidationError: 1 validation error for Movie # E year # E ensure this value is greater than 1800 (type=value_error.number.not_gt; limit_value=1800) Some of the most common Field arguments include: For numeric types like int , float and Decimal : gt Rquires the field to be greater than ge Rquires the field to be greater than or equal to le Rquires the field to be less than or equal to lt Rquires the field to be less than multiple_of Requires the field to be a multiple of For strings: min_length Requires the field to have a minimum length max_length Requires the field to have a maximum length regex Requires the field to match a regular expression For a full list of Field arguments you can refer to the Pydantic docs here .","title":"Field validation"},{"location":"defining_documents/#defining-indexes","text":"Mongox models accept indexes as a list of mongox.Index instances: import mongox indexes = [ mongox . Index ( \"name\" , unique = True ), mongox . Index ( keys = [( \"year\" , mongox . Order . DESCENDING ), ( \"genre\" , mongox . IndexType . HASHED )]), ] class Movie ( mongox . Model , db = db , indexes = indexes ): name : str genre : str year : int For creating Index objects we have two options, for simple cases we can do: Index ( key_name , ** kwargs ) But to have more control over index definition we can do: Index ( keys = [( key_name , index_order )], ** kwargs ) And then, you can then create the collection indexes with: await Movie . create_indexes () Or to drop the indexes: await Movie . drop_indexes () Note that this will only drop indexes defined in Movie model and won't affect the ones manually created. To drop all indexes, even those not defined here you can pass force=True : await Movie . drop_indexes ( force = True ) And finally if you need to drop a single index by name: await Movie . drop_index ( \"year_genre) Index accepts the following arguments: key For single key (simple indexes). keys List of keys and their types. name Can be specified or automatically generated from keys. background If the index creation should happen in the background. unique If the index should be a unique index. For example: Index ( keys = [( \"year\" , Order . DESCENDING )], name = \"year_index\" , background = True ) To specify order of index you can use mongox.Order : from mongox import Order Index ( keys = [( \"year\" , Order . ASCENDING )], name = \"year_index\" , background = True ) Order class has only two attributes ASCENDING and DESCENDING . And to specify custom index type, you can pass mongox.IndexType instead of index order: from mongox import IndexType Index ( keys = [( \"year\" , IndexType . HASHED )], name = \"year_index\" , background = True ) IndexType has the supported PyMongo index types: GEO2D GEOSPHERE HASHED TEXT For a full list of allowed arguments you can refer to the PyMongo docs here .","title":"Defining indexes"},{"location":"defining_documents/#embedded-models","text":"Embedded Models are models to be embedded in mongox.Model . The difference is that EmbeddedModel s won't be inserted separately and won't get their seaparate _id . To define Embedded Models you should inherit from mongox.EmbeddedModel and define the fields the same as Pydantic. import mongox class Genre ( mongox . EmbeddedModel ): title : str class Movie ( mongox . Model ): name : str genre : Genre You can use EmbeddedModel to define multi-level nested objects in MongoDB.","title":"Embedded Models"},{"location":"queriying_documents/","text":"Let's say we have defined the following documents: import typing import mongox class Movie ( mongox . Model ): name : str year : int tags : typing . List [ str ] Inserting documents Single insert In order to work with documents we'll first need to insert some. MongoX provides an insert method to the document instances. movie = await Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]) . insert () Of course we can also do it in two steps: movie = Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]) movie = await movie . insert () This will insert the following document in MongoDB: { \"name\" : \"Forrest Gump\" , \"year\" : 1994 , \"tags\" : [ \"Comedy\" , \"Drama\" ]} Bulk insert If you want to insert many documents at once, just use insert_many method: movies = [ Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]), Movie ( name = \"The Shawshank Redemption\" , year = 1994 , tags = [ \"Drama\" ]), ] movies = await Movie . insert_many ( movies ) The great thing about MongoX is that since it's fully type annotated, you will have great mypy and IDE support. Since Movie model is also a Pydantic model, you will have autocompletion in your IDE to know which fields are required. And you will also know that the result of insert will be a Movie instance. This will lead to more productivity and fewer runtime errors. Let's say you try to access genre of movie: print ( movie . genre ) Here mypy and your IDE will complain that the Movie class has no attribute genre . Querying documents MongoX supports the same queries Motor/PyMongo support and besides that, also introduces two other options. Let's say you want to query for a single document: You can do it the usual way, by passing a dictionary of key, values to filter: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () You can also query by Movie class fields: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use the new query builder (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Here you will again have graet IDE and MyPy support, as they will know the returned type of get will be a Movie . So you can access movie attributes safely. Query methods Here is the list of supported query methods: first returns the first matching document: movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . first () get returns the only matching document or throws exceptions: movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Note This can raise NoMatchFound or MultipleMatchesFound all returns all documents matching the criteria: movies = await Movie . query () . all () This will return a list of all matched documents. It's up to the caller to set the appropriate limits. You can also use the underlying generator to access queryset results. movies = Movie . query () async for movie in movies : print ( movie . name ) Notice that we have ommited .all() from the query, so the await is not needed. With Movie.query() we create a cursor only and looping through the cursor one item at a time. This can be useful for scenarios when you don't want to load all documents into memory. count returns count of documents matching the criteria: count = await Movie . query ( Movie . year == 1994 ) . count () sort to sort documents based on keys: movies = await Movie . query () . sort ( Movie . name , mongox . Order . DESCENDING ) . all () You can also chain multiple sort methods: movies = ( await Movie . query () . sort ( Movie . name , Order . DESCENDING ) . sort ( Movie . year , Order . ASCENDING ) . all () ) Or as a shortcut, you can use the mongox.Q class: movies = await Movie . query () . sort ( Q . asc ( Movie . name )) . all () Or chaining multiple sorts again: movies = ( await Movie . query () . sort ( Q . desc ( Movie . name )) . sort ( Q . asc ( Movie . year )) . all () ) get_or_create returns the only matching document or creates it with default arguments. movie = ( await Movie . query ( Movie . name == \"Forrest Gump\" , Movie . year == 1994 , Movie . tags == [ \"Comedy\" , \"Drama\" ] ) . get_or_create () ) The method has the ability to receive some other fields to be used for creation when document has not been found. movie = ( await Movie . query ( Movie . name == \"Forrest Gump\" ) . get_or_create ({ Movie . year : 1994 , Movie . tags : [ \"Comedy\" , \"Drama\" ]}) ) Here the Movie will be queried by name Forrest Gump and if not found, it will be created with: { \"name\" : \"Forrest Gump\" , \"year\" : 1994 , \"tags\" : [ \"Comedy\" , \"Drama\" ]} get_by_id A shortcut method to get single document by _id key: movie = await Movie . get_by_id ( \"507f1f77bcf86cd799439011\" ) limit to limit number of documents returned: movies = await Movie . query () . limit ( 5 ) . all () This will ensure that only 5 documents are returned. skip number of documents to skip: movies = await Movie . query () . skip ( 5 ) . all () This will skip the first 5 documents and return the rest. Sometimes skip is used with limit together: movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all () Chaining queries Some of the query methods return results including: all count first get These methods will return final results and should only be the last part of the query: movie = await Movie . query () . all () But some of the query methods return queryset again, so you can chain them together: query sort skip limit movies = await Movie . query ( Movie . name == \"Example\" ) . skip ( 10 ) . limit ( 20 ) . all () movies = await Movie . query ( Movie . name == \"Example\" ) . query ( Movie . year == 2005 ) . all () Updating documents MongoX provides the same updateOne and updateMany functions in MongoDB, but with a different API. You can update a document by calling save on it: movie = await Movie . query () . get () movie . name = \"Another Movie\" movie = await movie . save () Here the output of save will also be a Movie instance. This is the equivalent of a MongoDB updateOne . You can also do bulk updates like this: movies = await Movie . query ( Movie . year == 1970 ) . update ( year = 1980 , name = \"Another Movie\" ) Here we do an update to change the year and name of all 1970 movies to 1980 and the name Example to Another Movie. The returned result is a list of update Movie instances. This is the equivalent of updateMany in MongoDB. Note Note how bulk update is called on Movie class, but single update is called on Movie instance. Deleting documents The same as update, MongoX provides MongoDB deleteOne and deleteMany functions but with a different API. In order to delete a single document you should get a document first, then call delete on it: movie = await Movie . query () . get () await movie . delete () This will remove the movie instance and it is the equivalent of a deleteOne . To delete multiple documents at the same time: number_of_deleted = await Movie . query ( Movie . year == 1980 ) . delete () This will remove all documents having year equal to 1980, and the returned result is the number of documents deleted. Q operator The Q class contains some handy methods for creating queries. In order to create sort queries you might usually do this: movies = await Movie . query () . sort ( Movie . name , Order . DESCENDING ) . all () But as a short-cut you can use Q : Q.asc() Creates ASCENDING sort. movies = await Movie . query () . sort ( Q . asc ( Movie . name )) . all () Q.desc() Creates DESCENDING sort. movies = await Movie . query () . sort ( Q . desc ( Movie . name )) . all () There are also methods for creating more complex queries: Q.in_() Querying with $in operator. movies = await Movie . query ( Q . in_ ( Movie . year , [ 2000 , 2001 ])) . all () Q.not_in() Querying with $nin operator. movies = await Movie . query ( Q . not_in ( Movie . year , [ 2002 , 2003 ])) . all () Q.and_() Creating an $and operator. This will query for movie with name Forrest Gump and year 1994 . They are basically the same: movie = await Movie . query ( Q . and_ ( Movie . name == \"Forrest Gump\" , Movie . year == 1994 )) . all () movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . query ( Movie . year == 1994 ) . all () Q.or_() Creating an $or operator. This will match movies with name Forrest Gump or movies with year greater than 2000 . movies = await Movie . query ( Q . or_ ( Movie . name == \"Forrest Gump\" , Movie . year > 2000 )) . all () Q.contains() Querying inside lists nad strings. This will query for movies with tag Drama . movies = await Movie . query ( Q . contains ( Movie . tags , \"Drama\" )) . all () This will query for movies which in the name contains Forrest . movies = await Movie . query ( Q . contains ( Movie . name , \"Forrest\" )) . all () This will query for movies which the name matches \\w+ Two \\w+ . movies = await Movie . query ( Q . regex ( Movie . name , r \"\\w+ The \\w+\" )) . all () Embedded Models Now we change our Movie class to include a Genre : import mongox class Genre ( mongox . EmbeddedModel ): name : str class Movie ( mongox . Model ): name : str genre : Genre then we can create Movie instances with Genre : genre = Genre ( name = \"Action\" ) await Movie ( name = \"Saving Private Ryan\" , genre = genre ) . insert () This will create the following document in MongoDB: { \"name\" : \"Saving Private Ryan\" , \"genre\" : { \"name\" : \"Action\" }} You can then query the movie by embedded model fields: await Movie . query ( Movie . genre . name == \"Action\" ) . get () This will be equivalent to the following filter: { \"genre.name\" : \"Action\" } Or by using the complete embedded model: await Movie . query ( Movie . genre == genre ) . get () This will be equivalent to the following filter: { \"genre\" : { \"name\" : \"Action\" }}","title":"Working with documents"},{"location":"queriying_documents/#inserting-documents","text":"","title":"Inserting documents"},{"location":"queriying_documents/#single-insert","text":"In order to work with documents we'll first need to insert some. MongoX provides an insert method to the document instances. movie = await Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]) . insert () Of course we can also do it in two steps: movie = Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]) movie = await movie . insert () This will insert the following document in MongoDB: { \"name\" : \"Forrest Gump\" , \"year\" : 1994 , \"tags\" : [ \"Comedy\" , \"Drama\" ]}","title":"Single insert"},{"location":"queriying_documents/#bulk-insert","text":"If you want to insert many documents at once, just use insert_many method: movies = [ Movie ( name = \"Forrest Gump\" , year = 1994 , tags = [ \"Comedy\" , \"Drama\" ]), Movie ( name = \"The Shawshank Redemption\" , year = 1994 , tags = [ \"Drama\" ]), ] movies = await Movie . insert_many ( movies ) The great thing about MongoX is that since it's fully type annotated, you will have great mypy and IDE support. Since Movie model is also a Pydantic model, you will have autocompletion in your IDE to know which fields are required. And you will also know that the result of insert will be a Movie instance. This will lead to more productivity and fewer runtime errors. Let's say you try to access genre of movie: print ( movie . genre ) Here mypy and your IDE will complain that the Movie class has no attribute genre .","title":"Bulk insert"},{"location":"queriying_documents/#querying-documents","text":"MongoX supports the same queries Motor/PyMongo support and besides that, also introduces two other options. Let's say you want to query for a single document: You can do it the usual way, by passing a dictionary of key, values to filter: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () You can also query by Movie class fields: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use the new query builder (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Here you will again have graet IDE and MyPy support, as they will know the returned type of get will be a Movie . So you can access movie attributes safely.","title":"Querying documents"},{"location":"queriying_documents/#query-methods","text":"Here is the list of supported query methods: first returns the first matching document: movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . first () get returns the only matching document or throws exceptions: movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Note This can raise NoMatchFound or MultipleMatchesFound all returns all documents matching the criteria: movies = await Movie . query () . all () This will return a list of all matched documents. It's up to the caller to set the appropriate limits. You can also use the underlying generator to access queryset results. movies = Movie . query () async for movie in movies : print ( movie . name ) Notice that we have ommited .all() from the query, so the await is not needed. With Movie.query() we create a cursor only and looping through the cursor one item at a time. This can be useful for scenarios when you don't want to load all documents into memory. count returns count of documents matching the criteria: count = await Movie . query ( Movie . year == 1994 ) . count () sort to sort documents based on keys: movies = await Movie . query () . sort ( Movie . name , mongox . Order . DESCENDING ) . all () You can also chain multiple sort methods: movies = ( await Movie . query () . sort ( Movie . name , Order . DESCENDING ) . sort ( Movie . year , Order . ASCENDING ) . all () ) Or as a shortcut, you can use the mongox.Q class: movies = await Movie . query () . sort ( Q . asc ( Movie . name )) . all () Or chaining multiple sorts again: movies = ( await Movie . query () . sort ( Q . desc ( Movie . name )) . sort ( Q . asc ( Movie . year )) . all () ) get_or_create returns the only matching document or creates it with default arguments. movie = ( await Movie . query ( Movie . name == \"Forrest Gump\" , Movie . year == 1994 , Movie . tags == [ \"Comedy\" , \"Drama\" ] ) . get_or_create () ) The method has the ability to receive some other fields to be used for creation when document has not been found. movie = ( await Movie . query ( Movie . name == \"Forrest Gump\" ) . get_or_create ({ Movie . year : 1994 , Movie . tags : [ \"Comedy\" , \"Drama\" ]}) ) Here the Movie will be queried by name Forrest Gump and if not found, it will be created with: { \"name\" : \"Forrest Gump\" , \"year\" : 1994 , \"tags\" : [ \"Comedy\" , \"Drama\" ]} get_by_id A shortcut method to get single document by _id key: movie = await Movie . get_by_id ( \"507f1f77bcf86cd799439011\" ) limit to limit number of documents returned: movies = await Movie . query () . limit ( 5 ) . all () This will ensure that only 5 documents are returned. skip number of documents to skip: movies = await Movie . query () . skip ( 5 ) . all () This will skip the first 5 documents and return the rest. Sometimes skip is used with limit together: movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all ()","title":"Query methods"},{"location":"queriying_documents/#chaining-queries","text":"Some of the query methods return results including: all count first get These methods will return final results and should only be the last part of the query: movie = await Movie . query () . all () But some of the query methods return queryset again, so you can chain them together: query sort skip limit movies = await Movie . query ( Movie . name == \"Example\" ) . skip ( 10 ) . limit ( 20 ) . all () movies = await Movie . query ( Movie . name == \"Example\" ) . query ( Movie . year == 2005 ) . all ()","title":"Chaining queries"},{"location":"queriying_documents/#updating-documents","text":"MongoX provides the same updateOne and updateMany functions in MongoDB, but with a different API. You can update a document by calling save on it: movie = await Movie . query () . get () movie . name = \"Another Movie\" movie = await movie . save () Here the output of save will also be a Movie instance. This is the equivalent of a MongoDB updateOne . You can also do bulk updates like this: movies = await Movie . query ( Movie . year == 1970 ) . update ( year = 1980 , name = \"Another Movie\" ) Here we do an update to change the year and name of all 1970 movies to 1980 and the name Example to Another Movie. The returned result is a list of update Movie instances. This is the equivalent of updateMany in MongoDB. Note Note how bulk update is called on Movie class, but single update is called on Movie instance.","title":"Updating documents"},{"location":"queriying_documents/#deleting-documents","text":"The same as update, MongoX provides MongoDB deleteOne and deleteMany functions but with a different API. In order to delete a single document you should get a document first, then call delete on it: movie = await Movie . query () . get () await movie . delete () This will remove the movie instance and it is the equivalent of a deleteOne . To delete multiple documents at the same time: number_of_deleted = await Movie . query ( Movie . year == 1980 ) . delete () This will remove all documents having year equal to 1980, and the returned result is the number of documents deleted.","title":"Deleting documents"},{"location":"queriying_documents/#q-operator","text":"The Q class contains some handy methods for creating queries. In order to create sort queries you might usually do this: movies = await Movie . query () . sort ( Movie . name , Order . DESCENDING ) . all () But as a short-cut you can use Q : Q.asc() Creates ASCENDING sort. movies = await Movie . query () . sort ( Q . asc ( Movie . name )) . all () Q.desc() Creates DESCENDING sort. movies = await Movie . query () . sort ( Q . desc ( Movie . name )) . all () There are also methods for creating more complex queries: Q.in_() Querying with $in operator. movies = await Movie . query ( Q . in_ ( Movie . year , [ 2000 , 2001 ])) . all () Q.not_in() Querying with $nin operator. movies = await Movie . query ( Q . not_in ( Movie . year , [ 2002 , 2003 ])) . all () Q.and_() Creating an $and operator. This will query for movie with name Forrest Gump and year 1994 . They are basically the same: movie = await Movie . query ( Q . and_ ( Movie . name == \"Forrest Gump\" , Movie . year == 1994 )) . all () movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . query ( Movie . year == 1994 ) . all () Q.or_() Creating an $or operator. This will match movies with name Forrest Gump or movies with year greater than 2000 . movies = await Movie . query ( Q . or_ ( Movie . name == \"Forrest Gump\" , Movie . year > 2000 )) . all () Q.contains() Querying inside lists nad strings. This will query for movies with tag Drama . movies = await Movie . query ( Q . contains ( Movie . tags , \"Drama\" )) . all () This will query for movies which in the name contains Forrest . movies = await Movie . query ( Q . contains ( Movie . name , \"Forrest\" )) . all () This will query for movies which the name matches \\w+ Two \\w+ . movies = await Movie . query ( Q . regex ( Movie . name , r \"\\w+ The \\w+\" )) . all ()","title":"Q operator"},{"location":"queriying_documents/#embedded-models","text":"Now we change our Movie class to include a Genre : import mongox class Genre ( mongox . EmbeddedModel ): name : str class Movie ( mongox . Model ): name : str genre : Genre then we can create Movie instances with Genre : genre = Genre ( name = \"Action\" ) await Movie ( name = \"Saving Private Ryan\" , genre = genre ) . insert () This will create the following document in MongoDB: { \"name\" : \"Saving Private Ryan\" , \"genre\" : { \"name\" : \"Action\" }} You can then query the movie by embedded model fields: await Movie . query ( Movie . genre . name == \"Action\" ) . get () This will be equivalent to the following filter: { \"genre.name\" : \"Action\" } Or by using the complete embedded model: await Movie . query ( Movie . genre == genre ) . get () This will be equivalent to the following filter: { \"genre\" : { \"name\" : \"Action\" }}","title":"Embedded Models"}]}